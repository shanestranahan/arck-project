<!DOCTYPE HTML>
<html>
<head>
	<meta charset="UTF-8">
	<title>GLTF Test w/ Three.js</title>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, initial-scale=1">
</head>
<body style="margin:0;">
	<div id="container" style="height:3000px;">
	</div>
	<script src="three.min.js"></script>

	<script src="CopyShader.js"></script>

	<script src="EffectComposer.js"></script>
	<script src="GLTFLoader.js"></script>
	<script src="RenderPass.js"></script>
	<script src="ShaderPass.js"></script>

	<script src="stats.min.js"></script>
	<script>


		let scene, camera, model, boundingBoxFinal, stats, composer;

		init();
		animate();


		function init() {

			// INITIAL ASSIGNS
			// Assign global variables, width, height
			let container = document.getElementById( 'container' );
			let width = window.innerWidth;
			let height = window. innerHeight

			// CREATE SCENE
			scene = new THREE.Scene();

			// CREATE CAMERA
			// Create camera and set its position
			camera = new THREE.PerspectiveCamera(
				75, // FOV
				width / height, // Aspect ratio
				0.1, // minimum render distance
				100 // maximum render distance
			);
			camera.position.y = .3;
			camera.position.z = 1;

			// CREATE RENDERER
			let renderer = new THREE.WebGLRenderer(
				{ alpha: true },
				{ antialias: true }
			);
			renderer.physicallyCorrectLights = true;
			renderer.gammaOutput = true;
			renderer.gammaFactor = 2.2;
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFShadowMap;
			renderer.shadowMap.autoUpdate = true;
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( 0xffffff, 0 );
			container.appendChild( renderer.domElement );
			renderer.domElement.style.position = "fixed";

			// ADD STATS
			stats = new Stats();
			container.appendChild( stats.dom );

			// COMPOSER
			composer = new THREE.EffectComposer( renderer );
			let renderPass = new THREE.RenderPass( scene, camera );
			composer.addPass( renderPass );
			renderPass.renderToScreen = true;

			// ADD GLTF LOADER
			let objectLoader = new THREE.GLTFLoader();
			objectLoader.load(
				// Select specific GLTF file
				'bust_of_emperor_commodus_getty_villa/scene.gltf',
				// If working, add gltf to scene
				function ( gltf ) {
					model = gltf.scene;

					// Create bounding box with info on size, then rescale to max size of 1
					let boundingBox = new THREE.Box3().setFromObject( model );
					let boundingBoxSize = boundingBox.getSize( new THREE.Vector3() );
					let maxAxis = Math.max( boundingBoxSize.x, boundingBoxSize.y, boundingBoxSize.z );
					model.scale.multiplyScalar( 1.0 / maxAxis );


					// Reset bounding box, create its center as inverted array, translate model along that array, reset bounding box
					boundingBox.setFromObject(model);
					let boxCenter = boundingBox.getCenter( new THREE.Vector3() );
				    model.position.x += (model.position.x - boxCenter.x);
				    model.position.y += (model.position.y - boxCenter.y);
				    model.position.z += (model.position.z - boxCenter.z);
					boundingBoxFinal = boundingBox.setFromObject(model);


					// Add bounding box helper
					let boundingBoxHelper = new THREE.Box3Helper(boundingBox, 0xffff00);
					scene.add(boundingBoxHelper);

					// Add grid helper
					let gridHelper = new THREE.GridHelper();
					scene.add(gridHelper);

				    model.updateMatrixWorld();
					// Add model to scene
					scene.add( model );
				},
				// Create 'loading' countdown output
				function ( xhr ) {
					console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
				},
				// Create 'error' output
				function ( error ) {
					console.log ( 'An error happened' );
				}
			);
		}

		// CREATE FOCAL POINT
		// Creates a vector in reference to the bounding box of a given model.
		// Takes three values, usually set in a closed interval between 0 and 1.
		// Creates arrays from vectors of min and max of bounding box, then uses provided values to interpolate between the two ends of this range, returning the output as a single vector.
		setPointInModel = function( rangeX, rangeY, rangeZ ) {
			let minArray = [], maxArray = [];
			boundingBoxFinal.min.toArray( minArray );
			boundingBoxFinal.max.toArray( maxArray );

			let xValue = THREE.Math.lerp( minArray[0], maxArray[0], rangeX );
			let yValue = THREE.Math.lerp( minArray[1], maxArray[1], rangeY );
			let zValue = THREE.Math.lerp( minArray[2], maxArray[2], rangeZ );

			let output = new THREE.Vector3( xValue, yValue, zValue );
			return output;
		}


		window.addEventListener('scroll', function() {
			camera.position.x = pageYOffset / 1000;
			camera.position.z = 1 + (pageYOffset / 1000);
		});


		// RENDER LOOP
		// Function to animate the scene on the canvas
		function animate() {
			// Tell the browser that you want to animate, and request a function to update the animation on the next repaint. Prevents off-tab animation.
			requestAnimationFrame( animate );

			stats.begin();

			// If the model's loaded, set the camera to look at it a given point in it.
			if (model) camera.lookAt( setPointInModel(.5,.5,.5) );

			// Render the scene and the camera 
			// renderer.render( scene, camera );
			composer.render();
			stats.end();
		}
	</script>
</body>